#include <ctime>
#include <iomanip>
#include <sstream>
#include <string>
#include <chrono>
#include <fstream>

#include <wx/gauge.h>
#include <wx/sizer.h>
#include "wx/xrc/xmlres.h"

#include "logmanager.h"
#include "compilerfactory.h" //(ph 2020/12/2)
#include "compilercommandgenerator.h" //(ph 2020/12/2)
#include "loggers.h"
#include <configmanager.h>      //LSP diagnostics log
#include "loggers.h"


#include <../lspdiagresultslog.h>   //(ph 2020/10/25) LSP diagnostics log

#include "client.h"

// ----------------------------------------------------------------------------
namespace //annonymous
// ----------------------------------------------------------------------------
{
    const int idBuildLog = wxNewId();

}
// ----------------------------------------------------------------------------
namespace ClientHelp
// ----------------------------------------------------------------------------
{
    // Log declarations taken from directcommands.cpp   //(ph 2020/12/2)
    const wxString COMPILER_SIMPLE_LOG = _T("SLOG:");
    const wxString COMPILER_NOTE_LOG(_T("SLOG:NLOG:"));
    /// Print a NOTE log message to the build log, without advancing the progress counter
    const wxString COMPILER_ONLY_NOTE_LOG(_T("SLOG:ONLOG:"));
    const wxString COMPILER_WARNING_LOG(_T("SLOG:WLOG:"));
    const wxString COMPILER_ERROR_LOG(_T("SLOG:ELOG:"));
    const wxString COMPILER_TARGET_CHANGE(_T("SLOG:TGT:"));
    const wxString COMPILER_WAIT(_T("SLOG:WAIT"));
    const wxString COMPILER_WAIT_LINK(_T("SLOG:LINK"));

    const wxString COMPILER_NOTE_ID_LOG = COMPILER_NOTE_LOG.AfterFirst(wxT(':'));
    const wxString COMPILER_ONLY_NOTE_ID_LOG = COMPILER_ONLY_NOTE_LOG.AfterFirst(wxT(':'));
    const wxString COMPILER_WARNING_ID_LOG = COMPILER_WARNING_LOG.AfterFirst(wxT(':'));
    const wxString COMPILER_ERROR_ID_LOG = COMPILER_ERROR_LOG.AfterFirst(wxT(':'));

    // ----------------------------------------------------------------------------
    std::string GetTime_in_HH_MM_SS_MMM()
    // ----------------------------------------------------------------------------
    {
        using namespace std::chrono;

        // get current time
        auto now = system_clock::now();

        // get number of milliseconds for the current second
        // (remainder after division into seconds)
        auto ms = duration_cast<milliseconds>(now.time_since_epoch()) % 1000;

        // convert to std::time_t in order to convert to std::tm (broken time)
        auto timer = system_clock::to_time_t(now);
        // convert to broken time
        std::tm bt = *std::localtime(&timer);
        std::ostringstream oss;
        oss << std::put_time(&bt, "%H:%M:%S"); // HH:MM:SS
        oss << '.' << std::setfill('0') << std::setw(3) << ms.count();

        return oss.str();
    }


}//namespace clientHelp

// ----------------------------------------------------------------------------
ProcessLanguageClient::ProcessLanguageClient(const char *program, const char *arguments)
// ----------------------------------------------------------------------------
{
    m_LSP_responseStatus = false;
    pLSPClient           = this;

    // Find number of running CCLS servers and use that number as part of next log name
    wxString sep = wxFileName::GetPathSeparator();
    wxString tempDir = wxFileName::GetTempDir();

    // FIXME (ph#): is Tasklist.exe not always available, what about linux? ps -ef?
    wxString findCCLScmd = R"(tasklist.exe /nh /fi "IMAGENAME eq CB_CCLS-*")";
    wxArrayString runningCCLSvec;
    wxExecute(findCCLScmd, runningCCLSvec, wxEXEC_SYNC );
    size_t runningCCLS = 0;
    for (wxString entry : runningCCLSvec)
    {
        if (entry.StartsWith("CB_CCLS-"))
            runningCCLS += 1;
    }
    wxString nextLogNum = std::to_string(runningCCLS);
    wxString svrLogFilename = tempDir + sep +"CBccls_server-" + nextLogNum + ".log";
    if (wxFileExists(svrLogFilename)) wxRemoveFile(svrLogFilename);

    wxString command = wxT("F:\\usr\\proj\\CCLS\\CB_CCLS-5\\bin\\Release-5\\CB_CCLS-5.exe --log-file=" + svrLogFilename);
    command += R"( --init="{\"index\": {\"threads\": 0}}" )"; //0 means default 1/2 hardware cores

    wxString oldEnvPath;
    wxGetEnv("PATH", &oldEnvPath);
    // clear path of any conflicting dll directories, else crashes occur
    wxSetEnv("PATH", "") ;

    // override clang resource with --init='{"clang": {"resourceDir": "/usr/local/clang/7.0.0"}}'
    //?command.Append( wxT(" --init=\"{\\\"clang\\\": {\\\"resourceDir\\\": \\\"f:/User/Programs/msys64-2/mingw64/lib/clang/11.0.0\ \\\"}}"));

    /**
     * @brief start process
     * @param parent the parent. all events will be sent to this object
     * @param cmd command line to execute
     * @param flags possible creation flag
     * @param workingDir set the working directory of the executed process
     * @return
     */
    //IProcess* CreateAsyncProcess(wxEvtHandler* parent, const wxString& cmd,
    //                                            size_t flags = IProcessCreateDefault,
    //                                            const wxString& workingDir = wxEmptyString,
    //                                            const clEnvList_t* env = nullptr);
    pProcess = ::CreateAsyncProcess(this,
                    command,
                    IProcessCreateConsole | IProcessRawOutput | IProcessStderrEvent,  /*| IProcessStderrEvent | IProcessRawOutput*/
                    wxGetCwd()
                                           );
    // Create process asynchronously and return a process object
    //IProcess* Execute(wxEvtHandler* parent, const wxString& cmd, wxString& errMsg,
    //                 size_t flags = IProcessCreateDefault, const wxString& workingDir = wxEmptyString,
    //                 IProcessCallback* cb = NULL);

    //pProcess = new WinProcessImpl(this);
    //wxString sem("ErrorMsg from Execute()");
    //pProcess->Execute(this, command, sem, IProcessCreateConsole, wxGetCwd() );

    wxMilliSleep(1000);
    if (not pProcess)
        wxMessageBox(wxT("Error:Failed to create IProcess"));

    // Restore the modified PATH variable
    wxSetEnv("PATH", oldEnvPath) ;

    // if logging, open a log file and start a tail process
    #if defined(LOGGING)
        wxString strPID = wxString::Format(wxT("%d"), GetLSP_PID());
        wxString clientLogFilename = tempDir + "\\CBccls_client-" + nextLogNum + ".log";
        lspLogfile.Open( clientLogFilename,  wxFile::write );
        if (not lspLogfile.IsOpened())
            cbMessageBox(wxString::Format(wxT("Failed to open %s"), clientLogFilename ));
        else lspLogging = true;
    #endif //logging


    processPID = pProcess->GetPid();
    if ( (not pProcess) or (not pProcess->IsAlive()) )
    {
        cbMessageBox(wxString("IProcess for parser::OnBatchTimer() failed\n") + command.wx_str() );
    }

    Bind(wxEVT_ASYNC_PROCESS_OUTPUT, &ProcessLanguageClient::OnLSP_ResponseOutput, this);
    Bind(wxEVT_ASYNC_PROCESS_STDERR, &ProcessLanguageClient::OnLSP_Error, this);
    Bind(wxEVT_ASYNC_PROCESS_TERMINATED, &ProcessLanguageClient::OnLSP_Terminated, this);
    Connect(GetLSP_ID(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(ProcessLanguageClient::OnLSP_Response), nullptr, this);

    Manager::Get()->GetAppFrame()->PushEventHandler(this);

    if (not m_pDiagnosticsLog)
        CreateDiagnosticsLog();

    // ----------------------------------------------------------------------------
    // Thread: start Language Server Process input reader
    // ----------------------------------------------------------------------------
    MapMsgHndlr.SetLSP_ID(GetLSP_ID());
    //std::thread thread([&] {
    /*std::thread* */
    pInputThread = new std::thread([&] {
        loop(MapMsgHndlr);
    });
}//end ProcessLanguageClient()
// ----------------------------------------------------------------------------
ProcessLanguageClient::~ProcessLanguageClient()
// ----------------------------------------------------------------------------
{

    Manager::Get()->GetAppWindow()->RemoveEventHandler(this);

    Unbind(wxEVT_ASYNC_PROCESS_OUTPUT, &ProcessLanguageClient::OnLSP_Response, this);
    Unbind(wxEVT_ASYNC_PROCESS_STDERR, &ProcessLanguageClient::OnLSP_Error, this);
    Unbind(wxEVT_ASYNC_PROCESS_TERMINATED, &ProcessLanguageClient::OnLSP_Terminated, this);
    Disconnect(GetLSP_ID(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(ProcessLanguageClient::OnLSP_Response), nullptr, this);

    // Remove the LSP diagnostics log
    if (m_pDiagnosticsLog)
    {
        // Tell DragScroll plugin this log is closing
        wxWindow* pWindow = m_pDiagnosticsLog->m_pControl;
        cbPlugin* pPlgn = Manager::Get()->GetPluginManager()->FindPluginByName(_T("cbDragScroll"));
        if (pWindow && pPlgn)
        {
                wxCommandEvent dsEvt(wxEVT_COMMAND_MENU_SELECTED, XRCID("idDragScrollRemoveWindow"));
                dsEvt.SetClientData(pWindow);
                //Using ProcessEvent(), AddPendingEvent() does't work here. Wierd !!
                Manager::Get()->GetAppFrame()->GetEventHandler()->ProcessEvent(dsEvt);
        }

        CodeBlocksLogEvent evt(cbEVT_REMOVE_LOG_WINDOW, m_pDiagnosticsLog);
        Manager::Get()->GetAppWindow()->RemoveEventHandler((wxEvtHandler*)m_pDiagnosticsLog);
        Manager::Get()->ProcessEvent(evt);
        m_pDiagnosticsLog = nullptr; //LSPDiagnosticsLog was deleted by ProcessEvent()
    }

    terminateLSP = true; //tell the read thread to terminate

    if (pProcess and pProcess->IsAlive() ) {
        pProcess->Terminate();
        wxMilliSleep(500);
    }
    if (pProcess and pProcess->IsAlive()) {
        writeLog("~ProcessLanguageClient: Teminate process error!\n");
    }
    if (!TerminateThread((HANDLE)pInputThread->native_handle(), 0)) {            //(ph 2020/09/26)
        pInputThread->join();
        printf("terminate read thread error\n");
    }

    // setting terminateLSP should have already caused read thread to exit.
    if (pInputThread->joinable() )
        pInputThread->join();

    #if defined(LOGGING)
    lspLogfile.Close();
    #endif

    if (pProcess)
        delete pProcess;
    pProcess = nullptr;

    return;
}//end ~ProcessLanguageClient()
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::Has_LSPprocess()
// ----------------------------------------------------------------------------
{
    if ( (not pProcess) or (not pProcess->IsAlive()) ) //pProcess->GetPid() does not work
        return false;
    return true;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::writeLog(wxString logmsg)
// ----------------------------------------------------------------------------
{
    //-#undef LOGGING //(ph 2020/10/18)
    #if defined(LOGGING)
    wxString logcr = "";
    if (not logmsg.EndsWith(wxT("\n")) )
        logcr = "\n";
    //-lspLogfile.Write("\n" + GetTime() + " " + logmsg + logcr);
    lspLogfile.Write("\n" + ClientHelp::GetTime_in_HH_MM_SS_MMM() + " " + logmsg + logcr);
    lspLogfile.Flush();
    #endif
}
// ----------------------------------------------------------------------------
wxString ProcessLanguageClient::GetTime()
// ----------------------------------------------------------------------------
{
    wxDateTime now = wxDateTime::Now();
    return now.Format("%H:%M:%S", wxDateTime::Local);
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnLSP_Error(clProcessEvent& event)
// ----------------------------------------------------------------------------
{
    wxString errStr = event.GetOutput();
    if ( errStr.Length())

        writeLog(wxString::Format("-> OnLSP_Error():\n%s", errStr) );

    return;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnLSP_ResponseOutput(clProcessEvent& event)
// ----------------------------------------------------------------------------
{
    // concatenate LSP response to buffer
    LSP_OutputStr = LSP_OutputStr += event.GetOutput();
    if ( LSP_OutputStr.Length())
    {
        //writeLog(wxString::Format("-> OnLSP_ResponseOutput():\n%s", LSP_OutputStr) );
    }

    return;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnLSP_Terminated(wxCommandEvent& event_pipedprocess_terminated)
// ----------------------------------------------------------------------------
{
    int processExitCode = 0; //no good, return code is always 0
    if (GetLSP_Initialized()) processExitCode = -1; //terminated while initialized and running.
    if (pProcess)
    {
        //-pProcess->GetProcessExitCode(pProcess->GetPid(), processExitCode); no good. return code is always 0
        terminateLSP = true;   //tell read thread to exit.
        m_LSP_initialized = false;
        pProcess->Terminate(); //make sure LSP is terminated. Silly here but....
        for (int ii=8; ii and pProcess->IsAlive(); --ii )
        {
            //spin max 1 second for termination
            Manager::Yield();
            wxMilliSleep(125);
        }
        if (pProcess)
            delete pProcess;
        pProcess = nullptr;
    }
    m_LSP_initialized = false;
    if (processExitCode != 0)
        cbMessageBox("Unusual termination of LanguageProcessClient(LSP) occured.");
    return;
}//end OnLSP_Terminated()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::SkipLine()
// ----------------------------------------------------------------------------
{
    if ( (not Has_LSPprocess()) or ( LSP_OutputStr.empty()) )
        return ;

    int ndx = LSP_OutputStr.Find('\n');
    if (ndx == wxNOT_FOUND)
        return ;
    while( (LSP_OutputStr.Mid(ndx,1) == '\r') or (LSP_OutputStr(ndx,1) == '\n') )
        ndx += 1;
    LSP_OutputStr = LSP_OutputStr.Mid(ndx); //skip past \r\n
    return ;
}
// ----------------------------------------------------------------------------
int ProcessLanguageClient::ReadLength()
// ----------------------------------------------------------------------------
{

    // "Content-Length: nnnn\r\n"

    if (Has_LSPprocess() and LSP_OutputStr.Length())
    {
        int len = LSP_OutputStr.Find(wxT("Content-Length: "));
        if (len == wxNOT_FOUND)
            return 0;
        else
            return atoi(LSP_OutputStr.Mid(len + 16));
    }
    return 0;
}

// ----------------------------------------------------------------------------
void ProcessLanguageClient::Read(int length, std::string &out)
// ----------------------------------------------------------------------------
{
    if (Has_LSPprocess() and LSP_OutputStr.Length())
    {
        std::string ss = std::string(LSP_OutputStr.mb_str());
        for (size_t ii=0; ii<(size_t)length; ++ii)
        {
            if (LSP_OutputStr.Length() >= ii)
                out.append(1, ss[ii]);
            else out.append(1, ' ');
        }
        if (out.length())
            ;//writeLog(wxString::Format("Read()\n:%s", wxString(out)) );
        LSP_OutputStr = LSP_OutputStr.Mid(length); //remove used chars
        }
    return;
}//end Read()
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::WriteHdr(const std::string &in)
// ----------------------------------------------------------------------------
{
    wxString limitedLogOut(in.c_str(), wxConvUTF8);
    wxString out(in.c_str(), wxConvUTF8);
    // limit "text" output to log at 512 chars

    if (limitedLogOut.Contains("\"textDocument/didOpen\""))
    {
        int posnText = limitedLogOut.Find("\"text\":");
        int posnUri =  limitedLogOut.Find("\"uri\":");
        // if uri follows text, make adjustments
        if (posnUri > posnText)
        {
            int txtBeg = posnText + 7; //skip over "text":
            int txtEnd = posnUri - 4;  //skip back over "uri": where text ends
            int txtLen = txtEnd - txtBeg ;
            if (txtLen > 512)
            {
                wxString tmpStr = limitedLogOut.Left((txtBeg + 120)) + "<...snip...>" + limitedLogOut.Right(120);
                tmpStr.Append(limitedLogOut.Mid(posnUri-8) ); //append uri to end
                limitedLogOut = tmpStr;
            }
        }
        else
        limitedLogOut = wxString::Format("<- Write():\n%s", wxString(in)).Mid(0,512) + "<...data sniped by log write()...>";
    }//endif contains didOpen

    writeLog(limitedLogOut );
    bool ok = pProcess->WriteRaw(in ); //adding \r\n crashes CCLS
    if (not ok)
    {
        writeLog("WriteHdr() failed WriteRaw()");
        return false;
    }

    return true;
}//end WriteHdr()
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::readJson(json &json)
// ----------------------------------------------------------------------------
{
    // function is driven by thread in transport::loop()
    // thread was started in constructor
    json.clear();
    int length = 0;
    std::string read;

    if ( terminateLSP or (not Has_LSPprocess()) )
    {   // terminate the read loop thread
        read = "{\"jsonrpc\":\"2.0\",\"Exit!\":\"Exit!\",\"params\":null}";
        length = read.length();
        json = json::parse(read);
        return true;
    }

    length = ReadLength();
    wxMilliSleep(100);
    if (not length) {
        return false;
    }

    SkipLine();
    Read(length, read);
    try {
        json = json::parse(read);
    } catch (std::exception &e) {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        writeLog(wxString::Format("\n-> readJson error:%s\n%s", e.what(), read.c_str()) ); //(ph 2020/08/21)
    }
    //printf("message %d:\n%s\n", length, read.c_str());
    // The following already provided by OnLSP_ResponseOutput():
    writeLog(wxString::Format("-> readJson() len:%d:\n%s", length, read.c_str()) ); //(ph 2020/08/21)
    return true;
}//end readJson
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::writeJson(json &json)
// ----------------------------------------------------------------------------
{
    if (not Has_LSPprocess()) return false;

    std::string content = json.dump();
    std::string header = "Content-Length: " + std::to_string(content.length()) + "\r\n\r\n" + content;
    //printf("send:\n%s\n", content.c_str());
    //printf("\nwriteJson_send:\n%s\n", content.c_str()); //(ph 2020/08/21)
    //writeLog(wxString::Format("\n-<writeJson():\n%s", content.c_str()) ); //(ph 2020/08/21)
    return WriteHdr(header);
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnLSP_Response(wxCommandEvent& event)
// ----------------------------------------------------------------------------
{
    // This member event was Connected in  ProcessLanguageClient() constructor;
    // and issued from  transport.h "int loop(MessageHandler &handler)"
    // with event.clientdata void* set to incoming json data

    m_LSP_responseStatus = true;
    if (not Has_LSPprocess()) return;

    json* pJson = (json*)event.GetClientData();

    #if defined(LOGGING)
        std::string see = pJson->dump(); //debugging
    #endif //LOGGING

    wxString rspHeader = event.GetString();

//    try
//    {
//        if (pJson->count("id"))
//        {
//            std::string idValue = pJson->at("id").get<std::string>();
//            if (idValue == "initialize")        { OnIDResult(event); }
//            else if (pJson->contains("method")) { OnIDMethod(event); }
//            else if (pJson->contains("result")) { OnIDResult(event); }
//            else if (pJson->contains("error") ) { OnIDError(event);  }
//        }
//        else if (pJson->contains("method"))
//        {
//            if (pJson->contains("params"))      { OnMethodParams(event); }
//        }
//        else if (pJson->contains("Exit!:Exit!") ) { ;}
//    }
//    catch(std::exception &err)
//    {
//        wxString errMsg(wxString::Format("\nOnLSP_Response() error: %s", err.what()) );
//        writeLog(errMsg);
//        cbMessageBox(errMsg);
//        return;
//    }
    try
    {
        if (pJson->size())
        {
            if (pJson->count("id"))
            {
                if (pJson->contains("initialize"))
                    OnIDResult(event)

;               else if (pJson->contains("method"))
                {
                    //-handler.onRequest(value["method"].get<std::string>(), value["params"], value["id"]);
                    //evt.SetString("id:method");
                    //evt.SetClientData(&value);
                    OnIDMethod(event);
                }
                else if (pJson->contains("result"))
                {
                    //evt.SetString("id:result");
                    //evt.SetClientData(&value);
                    OnIDResult(event);
                }
                else if (pJson->contains("error"))
                {
                    //evt.SetString("id:error");
                    //evt.SetClientData(&value);
                    OnIDError(event);
                }
            }
            else if (pJson->contains("method"))
            {
                if (pJson->contains("params"))
                {
                    OnMethodParams(event);
                }
            }
            else if (pJson->contains("Exit!")) //(ph 2020/09/26)
            {
                ;//break; //exit the thread;
            }
        }
    }
    catch(std::exception &err)
    {
        wxString errMsg(wxString::Format("\nOnLSP_Response() error: %s", err.what()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
        return;
    }

    return;
}//end OnLSP_Response()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnIDMethod(wxCommandEvent& event)
// ----------------------------------------------------------------------------
{
    //- unused- json* pJson = (json*)event.GetClientData();

}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnIDResult(wxCommandEvent& event)
// ----------------------------------------------------------------------------
{
    json* pJson = (json*)event.GetClientData();
    //#if defined(LOGGING)
    //    std::string see = pJson->dump(); //debugging
    //#endif //LOGGING

    wxCommandEvent lspevt(wxEVT_COMMAND_MENU_SELECTED, GetLSP_UserEventID());

    if (pJson->contains("id"))
    {
        wxString idValue;
        try { idValue = pJson->at("id").get<std::string>(); }
        catch(std::exception &err)
        {
            wxString errMsg(wxString::Format("\nOnIDResult() error: %s", err.what()) );
            writeLog(errMsg);
            cbMessageBox(errMsg);
            return;
        }

        if (idValue == "initialize")
        {
            m_LSP_initialized = true;
            lspevt.SetString("LSP_Initialized:true");
        }

        else if (idValue == "shutdown")
        {
            m_LSP_initialized = false;
            lspevt.SetString("LSP_Initialized:false");
            //-LSP_CCLS_Info(); //(ph 2020/10/22) debugging test
        }


        else if(idValue.StartsWith("textDocument/declaration")
                or idValue.StartsWith("textDocument/definition") )
        {
            lspevt.SetString(idValue + ":result");
            json resultValue = pJson->at("result"); // now array

            #if defined(LOGGING)
                std::string see = resultValue.dump(); //debugging
            #endif //LOGGING

        }// if textDocument/def... textDocument/decl...

        else if (idValue.StartsWith("textDocument/references") )
        {
            //{"jsonrpc":"2.0","id":"textDocument/references","result":[{"uri":"file:///F%3A/usr/Proj/HelloWxWorld/HelloWxWorldMain.cpp","range":{"start":{"line":49,"character":45},"end":{"line":49,"character":52}}},{"uri":"file:///F%3A/usr/Proj/HelloWxWorld/HelloWxWorldMain.cpp","range":{"start":{"line":89,"character":4},"end":{"line":89,"character":11}}}]}
            lspevt.SetString(idValue + ":result");
            json resultValue = pJson->at("result"); // now array

        }// if textDocument/references

        else if(idValue.StartsWith("textDocument/documentSymbol") )
        {
            //{"jsonrpc":"2.0","id":"textDocument/documentSymbol","result":[{"name":"wxbuildinfoformat","detail":"enum wxbuildinfoformat {}","kind":10,"range":{"start":{"line":19,"character":0},"end":{"line":20,"character":21}},"selectionRange":{"start":{"line":19,"character":5},"end":{"line":19,"character":22}},"children":[]},{"name":"short_f","detail":"short_f","kind":22,"range":{"start":{"line":20,"character":4},"end":{"line":20,"character":11}},"selectionRange":{"start":{"line":20,"character":4},"end":{"line":20,"character":11}},...etc
            //debugging wxString showit = pJson->dump(3); //pretty print with 3 tabs spacing //(ph 2020/10/30)
            //debugging writeLog(showit);
            //debugging return;
            lspevt.SetString(idValue + ":result");
            //-json resultValue = pJson->at("result"); // now array
        }
        else if(idValue.StartsWith("textDocument/completion") )
        {
            lspevt.SetString(idValue + ":result");
            SetCompletionBusy(false);
        }
        else if(idValue.StartsWith("textDocument/hover") )
        {
            lspevt.SetString(idValue + ":result");
        }
        else if(idValue.StartsWith("$ccls/info") )
        {
            //{"jsonrpc":"2.0","id":"$ccls/info","result":{"db":{"files":128,"funcs":3673,"types":3807,"vars":9085},"pipeline":{"lastIdle":0,"completed":1,"enqueued":1},"project":{"entries":0}}}

            lspevt.SetString(idValue + ":result");
            //    json resultValue = pJson->at("result"); // now array
            //    #if defined(LOGGING)
            //        std::string see = resultValue.dump(); //debugging
            //    #endif //LOGGING
            //    if (not resultValue.size())
            //    {
            //        // return an empty array
            //        //-wxArrayString* pAry = new wxArrayString;
            //        //     lspevt.SetClientData(pAry);
            //    }
            //    if (resultValue.size() )
            //    {
            //    //    #if defined(LOGGING)
            //    //        std::string see = resultValue.dump(); //debugging
            //    //    #endif //LOGGING
            //    //    json db = resultValue.at("db");
            //    //    json pipeline = resultValue.at("pipeline");
            //    //
            //    //    //-wxArrayString* pAry = new wxArrayString;
            //    //
            //    //    int files = db.at("files");
            //    //    pAry->Add(wxString::Format("files:%d"), files);
            //    //    int funcs = db.at("funcs");
            //    //     pAry->Add(wxString::Format("funcs:%d"), funcs);
            //    //    int types = db.at("types");
            //    //     pAry->Add(wxString::Format("types:%d"), types);
            //    //    int vars =  db.at("vars");
            //    //     pAry->Add(wxString::Format("vars:%d"), vars);
            //    //    //{"lastIdle":0,"completed":1,"enqueued":1}
            //    //    int lastIdle =  pipeline.at("lastIdle");
            //    //     pAry->Add(wxString::Format("lastIdle:%d"), lastIdle);
            //    //    int completed = pipeline.at("completed");
            //    //     pAry->Add(wxString::Format("completed:%d"), completed);
            //    //    int enqueued =  pipeline.at("enqueued");
            //    //     pAry->Add(wxString::Format("enqueued:%d"), enqueued);
            //    //    //"project":{"entries":0}}}
            //    //    int projectEntries = resultValue.at("project").at("entries");
            //    //     pAry->Add(wxString::Format("projectEntries:%d"), projectEntries);
            //    //    lspevt.SetClientData(pAry);
            //    }//endif resultValue.size()
        }//endif "$ccls/info"

    }//endif "id"

    // A copy of the json object is necessary for AddPendingEvent(). The current one
    // will be reused  by the readJson() function.
    // The new json object will be freed in CodeCompletion code.
    json* pJsonData = new json(*pJson);
    assert(pJsonData && "Failure to allocate json data in OnIDResult()");
    lspevt.SetClientData(pJsonData);
    Manager::Get()->GetAppFrame()->GetEventHandler()->AddPendingEvent(lspevt);

    return;

}//OnIDResult()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnIDError(wxCommandEvent& event)
// ----------------------------------------------------------------------------
{
    wxCommandEvent lspevt(wxEVT_COMMAND_MENU_SELECTED, GetLSP_UserEventID());

    //{"jsonrpc":"2.0","id":"textDocument/declaration","error":{"code":-32600,"message":"not indexed"}}

    json* pJson = (json*)event.GetClientData();

    wxString idValue;
    try { idValue = pJson->at("id").get<std::string>(); }
    catch(std::exception &err)
    {
        wxString errMsg(wxString::Format("\nOnIDError() error: %s", err.what()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
        return;
    }

    //if(idValue.StartsWith("textDocument/declaration")
    //            or idValue.StartsWith("textDocument/definition") )
    if(idValue.StartsWith("textDocument/") )
    {
        lspevt.SetString(idValue + ":error");
        if (idValue.Contains("/completion"))
            SetCompletionBusy(false);
    }
    else return; //for now

    // A copy of the json is necessary for AddPendingEvent().
    // The current one will be reused  by the readJson() function.
    // new json object will be freed in CodeCompletion::OnLSP_Event() code
    json* pJsonData = new json(*pJson);
    assert(pJsonData && "Failure to allocate json data in OnIDError()");
    lspevt.SetClientData(pJsonData);
    Manager::Get()->GetAppFrame()->GetEventHandler()->AddPendingEvent(lspevt);

}//end IDError
// ----------------------------------------------------------------------------
void ProcessLanguageClient::OnMethodParams(wxCommandEvent& event)
// ----------------------------------------------------------------------------
{
    json* pJson = (json*)event.GetClientData();
    wxString methodValue = pJson->at("method").get<std::string>();
    // event used to pass json object to code completion
    wxCommandEvent lspevt(wxEVT_COMMAND_MENU_SELECTED, GetLSP_UserEventID());

    // "$ccls/publishSkippedRanges"
    // "window/workDoneProgress/create"
    // "$ccls/publishSkippedRanges"
    // "$ccls/publishSemanticHighlight"

    // ----------------------------------------------------------------------------
    //" textDocument/publishDiagnostics"
    // ----------------------------------------------------------------------------
    // {"jsonrpc":"2.0",
    //      "method":"textDocument/publishDiagnostics",
    //       "params":{
    //         "uri":"file:///F%3A/usr/Proj/CCLS/CB_Client/HelloWorld/HelloWorld.cpp","diagnostics":[{"range":{"start":{"line":3,"character":16},"end":{"line":3,"character":19}},"severity":2,"code":2,"source":"ccls","message":"using directive refers to implicitly-defined namespace 'std'","relatedInformation":[]},{...
    if (methodValue == "textDocument/publishDiagnostics")
    {
        lspevt.SetString(methodValue + ":params");
    }

    // A copy of the json is necessary for AddPendingEvent(). The current one
    // will be reused  by the readJson() function.
    // The new json object will be freed in CodeCompletion code.
    json* pJsonData = new json(*pJson);
    assert(pJsonData && "Failure to allocate json data in OnMethodParams()");
    lspevt.SetClientData(pJsonData);
    Manager::Get()->GetAppFrame()->GetEventHandler()->AddPendingEvent(lspevt);

    return;

}//end OnMethodParams
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_Shutdown()
// ----------------------------------------------------------------------------
{
    if (Has_LSPprocess())
    {
        writeLog("<- Shutdown():\n") ;
        Shutdown(); //Tell LSP to close/save/whatever goodness
        Manager::Yield();

        // The following causes the shutdown to appear too slow
        ////wait for LSP shutdown response
        //for (int ii=8; ii and GetLSP_Initialized(); --ii)
        //{
        //    std::this_thread::sleep_for(std::chrono::milliseconds(125));
        //}
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(125)); // 1/4 second

    Exit();                     //Tell LSP to exit for good.
    Manager::Yield();
    m_LSP_initialized = false;

    // wait max 1 second or less for the exit
    for (int ii=8; ii and Has_LSPprocess(); --ii)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(125));
    }

    return;
}//end LSP_Shutdown()
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::ProjectOwnsFile(cbEditor* pcbEd, bool notify)
// ----------------------------------------------------------------------------
{
    bool owned = false;
    if (pcbEd)
    {
        // There must be an active project
        cbProject* pProject = Manager::Get()->GetProjectManager()->GetActiveProject();
        if (not pProject) owned = false;

        // For LSP, file must belong to a project, because project compile parameters are used
        // Find the project and ProjectFile this editor is holding.
        ProjectFile* pProjectFile = pcbEd->GetProjectFile();
        if (pProjectFile)
            pProject = pProjectFile->GetParentProject();
        if ( (not pProjectFile) or (not pProject) )
            owned = false;
        else owned = true;
        if ((not owned) and notify)
            cbMessageBox("LSP: This file is not contained in a loaded project.");
    }

    return owned;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_Initialize(wxString dirname)
// ----------------------------------------------------------------------------
{
    LSP_rootURI = dirname; // contains backword slashes
    dirname.Replace("\\", "/");

    // Call UpdateCompilationDatabase() with currently opened files before LSP initializtion
    // to assure that compile_commands.json contains entries with the correct compiler parameters.
    // Else they'll be parsed with clang defaults instead of our compiler settings.
    EditorManager* pEdMgr = Manager::Get()->GetEditorManager();

    for (int ii=0; ii< pEdMgr->GetEditorsCount(); ++ii)
    {
        // Find the project and ProjectFile this editor is holding.
        cbEditor* pcbEd = pEdMgr->GetBuiltinEditor(ii);
        if (pcbEd)
        {
            ProjectFile* pProjectFile = pcbEd->GetProjectFile();
            if (not pProjectFile) continue;
            cbProject* pProject = pProjectFile->GetParentProject();
            if (not pProject) continue;

            wxString filename = pcbEd->GetFilename();
            UpdateCompilationDatabase(pProject, filename);
        }
    }//for

    if (not GetLSP_Initialized())
    {
        writeLog(wxString::Format("<- Initialize():\n%s", dirname) );

        try {Initialize(string_ref("file:///" + dirname) ); }
        catch(std::exception &err)
        {
            //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
            wxString errMsg(wxString::Format("\nLSP_Initialize() error: %s\n%s", err.what(), dirname.c_str()) );
            writeLog(errMsg);
            cbMessageBox(errMsg);
        }

    }
    return;
}//end LSP_Initialize()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_Info() //Request CCLS current parsing status
// ----------------------------------------------------------------------------
{
    if (not GetLSP_Initialized()) {
        cbMessageBox("LSP: attempt to request $ccls/info before initialization.");
        return;
    }

    try { SendRequest("$ccls/info"); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_Info() error: %s\n%s", err.what(), "$ccls/info") );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_DidOpen(cbEditor* pcbEd)
// ----------------------------------------------------------------------------
{
    if (not GetLSP_Initialized()) {
        cbMessageBox("LSP: attempt to add file before initialization.");
        return ;
    }

    if (not ProjectOwnsFile(pcbEd))
        return;

    cbProject* pProject = Manager::Get()->GetProjectManager()->GetActiveProject();
    if (not pProject) return;

    wxString infilename = pcbEd->GetFilename();

    // Add file to compiler_commands.json if necessary
    UpdateCompilationDatabase(pProject, infilename);
    if ( compileCommandDBchanged )
    {
        // Reload .ccls and compiler_command.json
        compileCommandDBchanged = 0;
        // Tell LSP server to reload the changed compile_commands.json
        // note - SendNotify() NOT RequestId(), they're different.
        try { SendNotify("workspace/didChangeConfiguration" ); }
        catch(std::exception &err)
        {
            wxString errMsg(wxString::Format("\nNotity DidChangeConfiguration() error: %s\n%s", err.what(), "in LSP_DidOpen()" ) );
            writeLog(errMsg);
            cbMessageBox(errMsg);
        }
    }
    wxString fileURI = wxString(wxT("file:///")) + infilename;
    fileURI.Replace("\\", "/");
    DocumentUri docuri = DocumentUri(fileURI.c_str());
    cbStyledTextCtrl* pCntl = pcbEd->GetControl();
    if (not pCntl) return;

    // save current length of the file
    m_FileSizeHistory[pcbEd] = pCntl->GetLength();

    wxString strText = pCntl->GetText();

    // The following works, but is ugly
    //char buf[strText.Length()+1];
    //strcpy( buf, (const char*)strText.mb_str(wxConvUTF8) );
    //string_ref text(buf, strText.Length() );

    //const char* pText = strText.c_str().AsChar(); //works
    const char* pText = strText.mb_str();           //works

    // Can't do the following because GetText() intermediate buffer is freed
    // then pointer is returned pointing to garbage memory.
    // const char* pText = pCntl->GetText().c_str().AsChar();   //fails
    //string_ref text(pText);

    writeLog(wxString::Format("LSP_DidOpen:\n%s", docuri.c_str()) );

    try { DidOpen(docuri, string_ref(pText, strText.Length()) ); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_DidOpen() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}//end LSP_DidOpen()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_DidClose(cbEditor* pcbEd)
// ----------------------------------------------------------------------------
{
    if (not GetLSP_Initialized())
    {
        // Comment out to avoid flooding user with unuseful debugging msgs
        //cbMessageBox("LSP: attempt to close file before initialization.");
        return ;
    }

    bool notify = false;
    if (not ProjectOwnsFile(pcbEd, notify) )
        return;

    wxString infilename = pcbEd->GetFilename();
    wxString fileURI = wxString(wxT("file:///")) + infilename;
    fileURI.Replace("\\", "/");
    DocumentUri docuri = DocumentUri(fileURI.c_str());
    // There wont be a wxStyledTextCtrl !!
    //c-bStyledTextCtrl* pCntl = pcbEd->GetControl();
    //-if (not pCntl) return;

    writeLog(wxString::Format("LSP_DidClose File:\n%s", docuri.c_str()) );

    try {DidClose(docuri); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_DidClose() error: %s\n%s", err.what(), fileURI.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_DidSave(cbEditor* pcbEd)
// ----------------------------------------------------------------------------
{
    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to save file before initialization.");
        return ;
    }

    bool notify = false;
    if (not ProjectOwnsFile(pcbEd, notify) )
        return;

    wxString infilename = pcbEd->GetFilename();
    wxString fileURI = wxString(wxT("file:///")) + infilename;
    fileURI.Replace("\\", "/");
    DocumentUri docuri = DocumentUri(fileURI.c_str());

    writeLog(wxString::Format("LSP_DidSave File:\n%s", docuri.c_str()) );

    // Here only when editor was changed, so tell LSP server
    LSP_DidChange(pcbEd);

    try { DidSave(docuri); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_DidSave() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_GoToDefinition(cbEditor* pcbEd)
// ----------------------------------------------------------------------------
{
    // goto implementation

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to LSP_GoToDefinition before initialization.");
        return ;
    }

    if (not ProjectOwnsFile(pcbEd))  return;

    wxString fileURI = wxString(wxT("file:///")) + pcbEd->GetFilename();
    fileURI.Replace("\\", "/");
    //-fileURI.MakeLower().Replace("f:", "");

    cbStyledTextCtrl* pCtrl = pcbEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    Position position;
    const int posn      = pCtrl->GetCurrentPos();
    const int startPosn = pCtrl->WordStartPosition(posn, true);
    //-const int endPosn   = pCtrl->WordEndPosition(posn, true); //not needed
    position.line       = pCtrl->LineFromPosition(posn);
    position.character  = startPosn - pCtrl->PositionFromLine(position.line);
    writeLog(wxString::Format("GoToDefinition:\n%s,line[%d], char[%d]", docuri.c_str(), position.line, position.character) );

    //Tell LSP server if text has changed
    LSP_DidChange(pcbEd);

    // CB goto implementation == LSP GoToDefinition
    try { GoToDefinition(docuri, position); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_GoToDefinition() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_GoToDeclaration(cbEditor* pcbEd)
// ----------------------------------------------------------------------------
{
    // goto signature

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to LSP_GoToDeclaration before initialization.");
        return ;
    }
    if (not ProjectOwnsFile(pcbEd))
        return;

    wxString fileURI = wxString(wxT("file:///")) + pcbEd->GetFilename();
    fileURI.Replace("\\", "/");
    //-fileURI.MakeLower().Replace("f:", "");

    cbStyledTextCtrl* pCtrl = pcbEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    Position position;
    const int posn      = pCtrl->GetCurrentPos();
    const int startPosn = pCtrl->WordStartPosition(posn, true);
    //-const int endPosn   = pCtrl->WordEndPosition(posn, true); //not needed
    position.line       = pCtrl->LineFromPosition(posn);
    position.character  = startPosn - pCtrl->PositionFromLine(position.line);
    writeLog(wxString::Format("GoToDeclaration:\n%s,line[%d], char[%d]", docuri.c_str(), position.line, position.character) );

    // Tell server if text has changed
    LSP_DidChange(pcbEd);

    try { GoToDeclaration(docuri, position); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_GoToDeclaration() error: %s\n%s", err.what(), fileURI.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_FindReferences(cbEditor* pEd)
// ----------------------------------------------------------------------------
{
    // goto signature

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to LSP_FindReferences before initialization.");
        return ;
    }

    if ((not pEd) or (not ProjectOwnsFile(pEd)) )  return;

    wxString fileURI = wxString(wxT("file:///")) + pEd->GetFilename();
    fileURI.Replace("\\", "/");
    //-fileURI.MakeLower().Replace("f:", "");

    cbStyledTextCtrl* pCtrl = pEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    Position position;
    const int posn      = pCtrl->GetCurrentPos();
    const int startPosn = pCtrl->WordStartPosition(posn, true);
    //-const int endPosn   = pCtrl->WordEndPosition(posn, true); //not needed
    position.line       = pCtrl->LineFromPosition(posn);
    position.character  = startPosn - pCtrl->PositionFromLine(position.line);
    writeLog(wxString::Format("FindReferences:\n%s,line[%d], char[%d]", docuri.c_str(), position.line, position.character) );

    // Report changes to server else reported references will be wrong.
    LSP_DidChange(pEd);

    try { References(docuri, position); }
    catch(std::exception &err)
    {
        wxString errMsg(wxString::Format("\nLSP_FindReferences() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}//end LSP_FindReferences()

// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_GetSymbols(cbEditor* pEd)
// ----------------------------------------------------------------------------
{
    // goto signature

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to LSP_GetSymbols before initialization.");
        return ;
    }

    if ((not pEd) or (not ProjectOwnsFile(pEd)) ) return;

    wxString fileURI = wxString(wxT("file:///")) + pEd->GetFilename();
    fileURI.Replace("\\", "/");
    //-fileURI.MakeLower().Replace("f:", "");

    cbStyledTextCtrl* pCtrl = pEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    writeLog(wxString::Format("LSP_GetSymbols:\n%s", docuri.c_str()) );

    // Tell LSP server if text has changed
    LSP_DidChange(pEd);
    //get symbols
    try { DocumentSymbol(docuri); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_GetSymbols() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return ;
}//end LSP_GetSymbols()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_DidChange(cbEditor* pEd)
// ----------------------------------------------------------------------------
{
    // DidChange the text // FIXME (ph#): The whole file is being sent as "changed" here.

    //    method: textDocument/didChange
    //    params: DidChangeTextDocumentParams defined as follows:
    //    interface DidChangeTextDocumentParams {
    //        /**
    //         * The document that did change. The version number points
    //         * to the version after all provided content changes have
    //         * been applied.
    //         */
    //        textDocument: VersionedTextDocumentIdentifier;
    //
    //        /**
    //         * The actual content changes. The content changes describe single state
    //         * changes to the document. So if there are two content changes c1 (at
    //         * array index 0) and c2 (at array index 1) for a document in state S then
    //         * c1 moves the document from S to S' and c2 from S' to S''. So c1 is
    //         * computed on the state S and c2 is computed on the state S'.
    //         *
    //         * To mirror the content of a document using change events use the following
    //         * approach:
    //         * - start with the same initial content
    //         * - apply the 'textDocument/didChange' notifications in the order you
    //         *   receive them.
    //         * - apply the `TextDocumentContentChangeEvent`s in a single notification
    //         *   in the order you receive them.
    //         */
    //        contentChanges: TextDocumentContentChangeEvent[];
    //    }
    //
    //       An event describing a change to a text document.
    ///       If range and rangeLength are
    ///       omitted the new text is considered to be the full content of the document.

    //    export type TextDocumentContentChangeEvent = {
    //        /**
    //         * The range of the document that changed.
    //         */
    //        range: Range;
    //
    //        /**
    //         * The optional length of the range that got replaced.
    //         *
    //         * @deprecated use range instead.
    //         */
    //        rangeLength?: uinteger;
    //
    //        /**
    //         * The new text for the provided range.
    //         */
    //        text: string;
    //    } | {
    //        /**
    //         * The new text of the whole document.
    //         */
    //        text: string;
    //    }


    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to call LSP_DidChange() before initialization.");
        return ;
    }

    if ((not pEd) or (not ProjectOwnsFile(pEd)) )  return;

    wxString fileURI = wxString(wxT("file:///")) + pEd->GetFilename();
    fileURI.Replace("\\", "/");

    cbStyledTextCtrl* pCtrl = pEd->GetControl();
    if (not pCtrl) return;

    // If no modifications and prev length == current length
    // there's no need to send file to LSP server.
    if ( not pEd->GetModified() and ( m_FileSizeHistory[pEd] == pCtrl->GetLength()) )
        return;

    m_FileSizeHistory[pEd] = pCtrl->GetLength();

    int curPosn     = pCtrl->GetCurrentPos();
//            int curLine     = pCtrl->LineFromPosition(curPosn);
    int lineBgnNum  = pCtrl->LineFromPosition(curPosn);
    //int lineNext    = curLine + 1;
    lineBgnNum      = (lineBgnNum>0) ? lineBgnNum-1 : 0;
    // FIXME (ph#): Why am I having to write the whole file ??
    //  to keep deletes in sync??
    // initially set ending text position to eof and line begin at 0
    int lineEndNum = pCtrl->LineFromPosition(pCtrl->GetLength()) +1;
    lineBgnNum = 0;
    //// if next line number not last line, use next line for text range, else use eof
    //if (lineNext < lineEndNum) lineEndNum = lineNext;
    wxString edText = pCtrl->GetTextRange(pCtrl->PositionFromLine(lineBgnNum), pCtrl->PositionFromLine(lineEndNum));

    //avoid CCLS crash assersion "Expression: end.col == start.col" by appending \n
    // when typing at the end of the file.
    if (not edText.EndsWith("\n"))
    {
        if (platform::windows)
            edText.Append("\r");
        edText.Append("\n");
    }
//            size_t textLth  = edText.Length();
    //-size_t lineEndNum = pCtrl->LineFromPosition(pCtrl->GetLength()) +1;
    TextDocumentContentChangeEvent didChangeEvent;
//            Range range;
//            range.start.line = lineBgnNum;
//            range.start.character = 0;
//            range.end.line = lineEndNum;
//            //-range.end.character =   pCtrl->GetLength() - pCtrl->PositionFromLine(lineEndNum);
//            range.end.character = 0; //end = char 0 of next line
//            didChangeEvent.rangeLength = textLth;

    // Assure text is UTF8 before handing to DidChange()
    didChangeEvent.text = edText.ToUTF8();
//            didChangeEvent.range = range;
    std::vector<TextDocumentContentChangeEvent> tdcce{didChangeEvent};
    DocumentUri docuri = DocumentUri(fileURI.c_str());
//            writeLog(wxString::Format("DidChange: lineStrt[%d] colStrt[%d] lineEnd[%d] colEnd[%d] textLth[%d] text[%s]\n",
//                            range.start.line, range.start.character,
//                            range.end.line, range.end.character,
//                            didChangeEvent.rangeLength.value(),
//                            didChangeEvent.text) );

    try { DidChange(docuri, tdcce); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_DidChange error: %s\n%s", err.what(), fileURI.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return;
}//end LSP_DidChange()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_Completion(bool isAuto, cbEditor* pEd, int& tknStart, int& tknEnd)
// ----------------------------------------------------------------------------
{
    // Code completion

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to call LSP_Completion() before initialization.");
        return ;
    }

    if ((not pEd) or (not ProjectOwnsFile(pEd)) )  return;

    if (GetCompletionBusy()) return;

    // Tell LSP server if file has changed, else asking for completion w/o updating can crash CCLS
    LSP_DidChange(pEd); //(ph 2020/12/19) debugging

    wxString fileURI = wxString(wxT("file:///")) + pEd->GetFilename();
    fileURI.Replace("\\", "/");

    cbStyledTextCtrl* pCtrl = pEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    Position position;
    position.line        = pCtrl->LineFromPosition(tknStart);
    size_t lineStartPosn = pCtrl->PositionFromLine(position.line);
    size_t relativeTokenStart = tknStart - lineStartPosn;
    size_t relativeTokenEnd   = tknEnd - lineStartPosn;

    position.character   = relativeTokenEnd;
    //-position.character   = relativeTokenStart;
    CompletionContext context;
    context.triggerKind = CompletionTriggerKind::Invoked;
    context.triggerCharacter = ".";
    wxString lineText = pCtrl->GetLine(position.line);
    wxString token    = lineText.Mid(relativeTokenStart, tknEnd-tknStart);

    writeLog(wxString::Format("LSP Completion:\nline[%d], col[%d] token[%s] uri[%s]",
                              position.line, position.character, token.c_str(), docuri.c_str()) );

    try { Completion(docuri, position, context); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_Completion error: %s\n%s", err.what(), fileURI.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
        return;
    }

    SetCompletionBusy(true);
    return ;
}//end LSP_Completion()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::LSP_Hover(cbEditor* pEd)
// ----------------------------------------------------------------------------
{
    // Hover

    if (not GetLSP_Initialized())
    {
        cbMessageBox("LSP: attempt to call LSP_Hover() before initialization.");
        return ;
    }

    if ((not pEd) or (not ProjectOwnsFile(pEd)) )  return;
    wxString fileURI = wxString(wxT("file:///")) + pEd->GetFilename();
    fileURI.Replace("\\", "/");

    cbStyledTextCtrl* pCtrl = pEd->GetControl();
    if (not pCtrl) return;

    DocumentUri docuri = DocumentUri(fileURI.c_str());
    const int posn      = pCtrl->GetCurrentPos();
    const int startPosn = pCtrl->WordStartPosition(posn, true);
    Position position;
    position.line       = pCtrl->LineFromPosition(posn);
    position.character  = startPosn - pCtrl->PositionFromLine(position.line);
    writeLog(wxString::Format("Hover:\n%s,line[%d], char[%d]", docuri.c_str(), position.line, position.character) );

    // Inform LSP server if text has changed
    LSP_DidChange(pEd);

    try { Hover(docuri, position); }
    catch(std::exception &err)
    {
        //printf("read error -> %s\nread -> %s\n ", e.what(), read.c_str());
        wxString errMsg(wxString::Format("\nLSP_Hover() error: %s\n%s", err.what(), docuri.c_str()) );
        writeLog(errMsg);
        cbMessageBox(errMsg);
    }

    return;

}//end LSP_Hover()
// ----------------------------------------------------------------------------
std::string ProcessLanguageClient::LSP_GetTimeHMSM() //Get time in hours minute second milliseconds
// ----------------------------------------------------------------------------
{
     return ClientHelp::GetTime_in_HH_MM_SS_MMM();
}
// ----------------------------------------------------------------------------
void ProcessLanguageClient::CheckForTooLongCommandLine(wxString& executableCmd, wxArrayString& outputCommandArray,
                                    const wxString& basename ,const wxString& path) const //(ph 2020/12/2)
// ----------------------------------------------------------------------------
{

#ifndef CB_COMMAND_LINE_MAX_LENGTH
#ifdef __WXMSW__
// the actual limit is 32767 (source: https://devblogs.microsoft.com/oldnewthing/20031210-00/?p=41553 )
#define CB_COMMAND_LINE_MAX_LENGTH 32767
#else
// On Linux the limit should be inf
// List of collected length limits: https://www.in-ulm.de/~mascheck/various/argmax/
// Actual limit on Linux Mint 18 is 131072 (this is the limit for args + environ for exec())
#define CB_COMMAND_LINE_MAX_LENGTH 131072
#endif // __WXMSW__
#endif // CB_COMMAND_LINE_MAX_LENGTH
    const int maxLength = CB_COMMAND_LINE_MAX_LENGTH;
    if (executableCmd.length() > maxLength)
    {
        wxFileName responseFileName(path);
        responseFileName.SetName(basename);
        responseFileName.SetExt("respFile");
        // Path handling has to be so complicated because of wxWidgets error https://trac.wxwidgets.org/ticket/831
        // The path for creating the folder structure has to be relative
        const wxString responseFilePath = responseFileName.GetFullPath();
        wxFileName relative = responseFileName;
        relative.MakeRelativeTo(wxFileName::GetCwd());
        if (!wxFileName::Mkdir(relative.GetPath(), wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL))
        {
            outputCommandArray.Add(ClientHelp::COMPILER_ERROR_LOG + _("Could not create directory for ") + responseFilePath);
            return;
        }

        outputCommandArray.Add(ClientHelp::COMPILER_ONLY_NOTE_LOG + wxString::Format(_("Command line is too long: Using responseFile: %s"), responseFilePath));
        outputCommandArray.Add(ClientHelp::COMPILER_ONLY_NOTE_LOG + wxString::Format(_("Complete command line: %s"), executableCmd));

        // Begin from the back of the command line and search for a position to split it. A suitable position is a white space
        // so that the resulting command line inclusive response file is shorter than the length limit
        const int responseFileLength = responseFilePath.length();
        size_t startPos = executableCmd.rfind(' ', maxLength - responseFileLength);
        if (startPos == 0 || startPos == wxString::npos)   // Try to find the first command again...
            startPos = executableCmd.find(' ');
        if (startPos > maxLength)
        {
            outputCommandArray.Add(ClientHelp::COMPILER_WARNING_LOG + _("Could not split command line for response file. This probably will lead to failed compiling") );
        }
        wxString restCommand = executableCmd.Right(executableCmd.length() - startPos);
        outputCommandArray.Add(ClientHelp::COMPILER_ONLY_NOTE_LOG + wxString::Format(_("Response file: %s"), restCommand));
        // Path escaping Needed for windows.  '\' has to be '\\' in the response file for mingw-gcc
        restCommand.Replace("\\", "\\\\");
        wxFile file(responseFilePath, wxFile::OpenMode::write);
        if (!file.IsOpened())
        {
            outputCommandArray.Add(ClientHelp::COMPILER_ERROR_LOG + wxString::Format(_("Could not open response file in %s"), responseFilePath));
            return;
        }

        file.Write(restCommand);
        file.Close();
        executableCmd = executableCmd.Left(startPos) + " @\"" + responseFilePath + "\"";
        outputCommandArray.Add(ClientHelp::COMPILER_ONLY_NOTE_LOG + wxString::Format(_("New command: %s"), executableCmd));
    }
}//end CheckForTooLongCommandLine()
// ----------------------------------------------------------------------------
wxArrayString ProcessLanguageClient::GetCompileFileCommand(ProjectBuildTarget* pTarget, ProjectFile* pf) const
// ----------------------------------------------------------------------------
{
    // This code lifted from directcommand.cpp
    wxArrayString ret;
    wxArrayString ret_generated;

    // is it compilable?
    if (!pf || !pf->compile)
        return ret;

    if (pf->compilerVar.IsEmpty())
    {
        Manager::Get()->GetLogManager()->DebugLog(_("Cannot resolve compiler var for project file."));
        return ret;
    }

    // Verify that the projectFile is associated with the target, else crashes occur.
    wxArrayString buildTargets = pf->GetBuildTargets();
    if (not buildTargets.Count()) return ret;
    bool targetFound = false;
    for (wxString tgtTitle: buildTargets)
        if (tgtTitle == pTarget->GetTitle()) targetFound = true; //ok
    if (not targetFound) return ret;

    assert(pTarget && "Empty target pointer");
    Compiler* compiler = CompilerFactory::GetCompiler(pTarget->GetCompilerID());

    if (!compiler)
    {
        Manager::Get()->GetLogManager()->DebugLog(_("Can't access compiler for file."));
        return ret;
    }

    cbProject* pProject = pTarget->GetParentProject();
    if (not pProject) return ret;

    const pfDetails& pfd = pf->GetFileDetails(pTarget);
    wxString object      = (compiler->GetSwitches().UseFlatObjects)
                         ? pfd.object_file_flat : pfd.object_file;
    wxString object_dir  = (compiler->GetSwitches().UseFlatObjects)
                         ? pfd.object_dir_flat_native : pfd.object_dir_native;
    //-// create output dir
    //-if (!object_dir.IsEmpty() && !CreateDirRecursively(object_dir, 0755))
    //-    Manager::Get()->GetLogManager()->DebugLog(_("Can't create object output directory:\n") + object_dir);

    // lookup file's type
    const FileType ft = FileTypeOf(pf->relativeFilename);

    bool is_resource = ft == ftResource;
    bool is_header   = ft == ftHeader;

    // allowed resources under all platforms: makes sense when cross-compiling for
    // windows under linux.
    // and anyway, if the user is dumb enough to try to compile resources without
    // having a resource compiler, (s)he deserves the upcoming build error ;)

    wxString compiler_cmd;
    if (!is_header || compiler->GetSwitches().supportsPCH)
    {
        const CompilerTool* tool = compiler->GetCompilerTool(is_resource ? ctCompileResourceCmd : ctCompileObjectCmd, pf->file.GetExt());

        // does it generate other files to compile?
        for (size_t i = 0; i < pf->generatedFiles.size(); ++i)
            AppendArray(GetCompileFileCommand(pTarget, pf->generatedFiles[i]), ret_generated); // recurse

        pfCustomBuild& pcfb = pf->customBuild[compiler->GetID()];
        if (pcfb.useCustomBuildCommand)
            compiler_cmd = pcfb.buildCommand;
        else if (tool)
            compiler_cmd = tool->command;
        else
            compiler_cmd = wxEmptyString;

        wxString source_file;
        if (compiler->GetSwitches().UseFullSourcePaths)
            source_file = UnixFilename(pfd.source_file_absolute_native);
        else
            source_file = pfd.source_file;

#ifdef command_line_generation
        Manager::Get()->GetLogManager()->DebugLog(F(_T("GetCompileFileCommand[1]: compiler_cmd='%s', source_file='%s', object='%s', object_dir='%s'."),
                                                    compiler_cmd.wx_str(), source_file.wx_str(), object.wx_str(), object_dir.wx_str()));
#endif

        // for resource files, use short from if path because if windres bug with spaces-in-paths
        if (is_resource && compiler->GetSwitches().UseFullSourcePaths)
            source_file = pf->file.GetShortPath();

        QuoteStringIfNeeded(source_file);

#ifdef command_line_generation
        Manager::Get()->GetLogManager()->DebugLog(F(_T("GetCompileFileCommand[2]: source_file='%s'."),
                                                    source_file.wx_str()));
#endif
        cb::shared_ptr<CompilerCommandGenerator> generator(compiler ? compiler->GetCommandGenerator(pProject) : nullptr);
        generator->GenerateCommandLine(compiler_cmd, pTarget, pf, source_file, object,
                                          pfd.object_file_flat, pfd.dep_file);
    }

    if (!is_header && compiler_cmd.IsEmpty())
    {
        ret.Add(ClientHelp::COMPILER_SIMPLE_LOG + _("Skipping file (no compiler program set): ") + pfd.source_file_native );
        return ret;
    }

    switch (compiler->GetSwitches().logging)
    {
        case clogFull:
            ret.Add(ClientHelp::COMPILER_SIMPLE_LOG + compiler_cmd);
            break;

        case clogSimple:
            if (is_header)
                ret.Add(ClientHelp::COMPILER_SIMPLE_LOG + _("Pre-compiling header: ") + pfd.source_file_native );
            else
                ret.Add(ClientHelp::COMPILER_SIMPLE_LOG + _("Compiling: ") + pfd.source_file_native );
            break;

        case clogNone: // fall-through
        default:
            break;
    }

    CheckForTooLongCommandLine(compiler_cmd, ret, pf->file.GetFullName() ,object_dir);

    ret.Add(compiler_cmd);

    if (is_header)
        ret.Add(ClientHelp::COMPILER_WAIT);

    if (ret_generated.GetCount())
    {
        // not only append commands for (any) generated files to be compiled
        // but also insert a "pause" to allow this file to generate its files first
        if (!is_header) // if is_header, the "pause" has already been added
            ret.Add(ClientHelp::COMPILER_WAIT);
        AppendArray(ret_generated, ret);
    }

    // if it's a PCH, delete the previously generated PCH to avoid problems
    // (it 'll be recreated anyway)
    if ( (ft == ftHeader) && pf->compile )
    {
        wxString object_abs = (compiler->GetSwitches().UseFlatObjects)
                            ? pfd.object_file_flat_absolute_native
                            : pfd.object_file_absolute_native;

        if ( wxFileExists(object_abs) && !wxRemoveFile(object_abs) )
            Manager::Get()->GetLogManager()->DebugLog(_("Cannot remove old PCH file:\n") + object_abs);
    }

    return ret;
}//end GetCompileFileCommand()
// ----------------------------------------------------------------------------
bool ProcessLanguageClient::AddFileToCompileDBJson(cbProject* pProject, ProjectBuildTarget* pTarget, const wxString& argFullFilePath, json* pJson)    //(ph 2020/12/1)
// ----------------------------------------------------------------------------
{
    // Add file to compile_commands.json if not already present.

    // If the .ccls file exists then it will be used and compile_commands.json
    // will not be used. You can use both, but to do so you need to
    // (a) remove the %clang from your .ccls file and
    // (b) add %compile_commands.json to your .ccls file.
    // More info is available in https://github.com/madscientist/ccls/wiki/Customization#ccls-file
    // and https://github.com/madscientist/ccls/wiki/Project-Setup

    // Peronally, I found .ccls file exceedingly hard to use with undependable behavior.

    // gcc/g++ example flags to get extra includes "./g++.exe --% -E -Wp,-v -xc++ nul"
    // compile_commands.json needs the result of this to add to the command line.
    // else #include <files> will not be found.

    /*
        #include <...> search starts here:
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed
         F:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include
        End of search list.
    */

    wxString sep = "/";
    if (platform::windows) sep = "\\";

    wxString newFullFilePath = argFullFilePath;
    if (platform::windows)
        newFullFilePath.Replace(sep, "/");
    sep = "/";

    ProjectFile* pProjectFile = pProject->GetFileByFilename(newFullFilePath, false);
    if (not pProjectFile) return false;

    wxArrayString buildTargets = pProjectFile->GetBuildTargets();
    if (not buildTargets.Count()) return false;

    //-ProjectBuildTarget* pTarget = pProject->GetBuildTarget(buildTargets[0]);
    if (not pTarget) return false;

    wxArrayString compileCommands;

    if (FileTypeOf(pProjectFile->relativeFilename) == ftHeader)
    {
        //header files dont have compile commands
        //look for matching cpp and use its compile commands
        wxFileName cppFilename = pProjectFile->file;
        if (cppFilename.GetExt().Lower().StartsWith("h"))
            cppFilename.SetExt("cpp");
        if (cppFilename.GetExt().Lower() == "hh")
            cppFilename.SetExt("cc");
        ProjectFile* pfcpp =  pProject->GetFileByFilename(cppFilename.GetFullPath(), false);
        if (not pfcpp) return false;
        compileCommands = GetCompileFileCommand(pTarget, pfcpp);
        if (not compileCommands.Count()) return false;
    }
    else
    {
        // Not a header file
        compileCommands = GetCompileFileCommand(pTarget, pProjectFile);
        if (not compileCommands.Count()) return false;
    }

    wxString compileCommand;
    for (size_t ccknt=0; ccknt<compileCommands.Count(); ++ccknt)
    {
        // Some entries start with "SLOG:g++.exe ..." etc
        //-wxString look = compileCommands[ccknt]; debugging
        if ( compileCommands[ccknt].StartsWith("SLOG:") )
            continue;
        compileCommand = compileCommands[ccknt]; // use the first good compile command.
        break;
    }
    if (compileCommand.empty()) return false;

    // Add the extra search directories
    wxString compilerID = pTarget->GetCompilerID();
    wxString compilerIncludes = LSPCompilerIncludes[compilerID];
    if (compilerIncludes.Length())
    {
        //-for ( wxString& extraInclude : LSPParseExtraIncludes)
        compileCommand.Append(" " + compilerIncludes.Trim(true).Trim(false) );
    }

    compileCommand.Replace("\\", "/");

    wxFileName fnNewFullFilePath(newFullFilePath);

    json newEntry;
    newEntry["directory"] = wxPathOnly(newFullFilePath);
    newEntry["command"]   = compileCommand;
    newEntry["file"]      = fnNewFullFilePath.GetFullName();
    newEntry["output"]    = buildTargets[0];

    // The file name has to be relative to the active project dir
    // The active project dir goes to newEntry
    cbProject* activeProject = Manager::Get()->GetProjectManager()->GetActiveProject();
    if (pProject != activeProject)
    {
        wxFileName fnActiveProject(activeProject->GetFilename());
        wxString dirPath = fnActiveProject.GetPath();
        dirPath.Replace("\\","/");

        wxFileName relFilename = fnNewFullFilePath;
        relFilename.MakeRelativeTo(fnActiveProject.GetPath());
        wxString relFileName  = relFilename.GetFullPath();
        relFileName.Replace("\\","/");
        newEntry["directory"] = dirPath;
        newEntry["file"] = relFileName;

    }

    // If this file already in compile_commands.json just leave it.
    // changing it will cause LSP server to reload the src file and compiler_commands.json
    int entryknt = pJson->size();
//    if (0 == entryknt)
//    {
//        // add the first newentry
//        pJson->push_back(newEntry);
//        //SetCompile_CommandsChanged(true);
//        compileCommandDBchanged++;
//    }
    // Remove the older entry if any
    size_t found = 0, changed = 0;
    for (int ii=0; ii<entryknt; ++ii)
    {
        json entry;
        try { entry =  pJson->at(ii); }
        catch(std::exception &err)
        {
            wxString errMsg(wxString::Format("\nAddFileToCompileDBJson() error: %s\n", err.what()) );
            writeLog(errMsg);
            cbMessageBox(errMsg);
        }
        //wxString look = entry.dump(); //debugging
        std::string ccjDir     = entry["directory"];
        std::string ccjFile    = entry["file"];
        std::string ccjCommand = entry["command"];

        wxString ccjPath = ccjDir + sep + ccjFile ;
        wxString newfile = newEntry["directory"].get<std::string>();
        newfile += "/" + newEntry["file"].get<std::string>();
        if (ccjPath == newfile)
        {
            // filename and directory name have matched.
            // If commands match, leave entry alone.
            if (not found)
            {
                found++;    //update first entry only
                if (ccjCommand != newEntry["command"])
                {
                    pJson->at(ii) = newEntry;
                    changed++;
                }
//                if (ccjFile != newEntry["file"]) //namepath vs fullpath
//                {
//                    pJson->at(ii) = newEntry;
//                    changed++;
//                }
                continue;
            }
                // debugging: write changes to log
                //writeLog(wxString::Format("AddFileToCompilerDBJson File:%s", ccjPath.c_str()) );
                //writeLog(wxString::Format("\tOldCommand:%s", ccjCommand.c_str()) );
                //writeLog(wxString::Format("\tNewCommand:%s", newEntry["command"].get<std::string>()) );

            //This is a duplicate entry
            // duplicate entries.
            try {   pJson->erase(ii);
            } catch (std::exception &e)
            {
                writeLog(wxString::Format("\nAddFileToCompileDBJson() error:%s erase", e.what()) );
                return false;
            }
            changed++; //file has been changed
            --entryknt;
            --ii;
        }//endif
    }//endfor

    // add the new or changed entry
    if ((not found) or changed)
    {
        if (not found)
            pJson->push_back(newEntry);
        //SetCompile_CommandsChanged(true);
        compileCommandDBchanged++;
    }

    //wxString look = pJson->dump(); debugging
    if (compileCommandDBchanged)
        return true;
    return false;

}//end AddFileToCompileDBJson()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::UpdateCompilationDatabase(cbProject* pProject, wxString filename)             //(ph 2020/12/1)
// ----------------------------------------------------------------------------
{
    // create compilation database 'compile_commands.json' from project files.
    // If compile_commands.json already exists, use it to insert project file data.
    // compile_commands.json format: https://clang.llvm.org/docs/JSONCompilationDatabase.html
    // [
    //    { "directory": "/home/user/llvm/build",
    //      "command": "/usr/bin/clang++ -Irelative -DSOMEDEF=\"With spaces, quotes and \\-es.\" -c -o file.o file.cc",
    //      "file": "file.cc" ,
    //      "output": "targetName"
    //    },
    //    ...
    // ]
    std::fstream jsonFile;           //("out.json", std::ofstream::in | std::ofstream::out);
    json jdb = json::array();        //create the main array
    //  compile_commands.json must be for the active project, not the ProjectFile.parentProject.
    cbProject* pActiveProject = Manager::Get()->GetProjectManager()->GetActiveProject();
    wxString prjFolder = pActiveProject->GetFilename();
    wxString cdbFullPath = wxPathOnly(prjFolder) + R"(/compile_commands.json)";
    if (wxFileExists(cdbFullPath)) switch(1)
    {
        default:
        jsonFile.open (cdbFullPath, std::ofstream::in);
        if (not jsonFile.is_open())
        {
            cbMessageBox("Existing compile_commands.json file failed to open.\n");
            break;
        }
        jsonFile >> jdb; //read file json object
        jsonFile.close();
    }//endif wxFileExists

    // create array of compiler built-in include files needed for for clang '-fsyntax-only'
    // The files arn't found by clang for some unknown reason to me.
    wxArrayString gccResults, gccErrors;

    ProjectBuildTarget* pTarget = nullptr;
    if (not pTarget)  // No target when target is virtual (eg. 'ALL');
    {
        // Use the first target associated with this file.
        ProjectFile* pProjectFile = pProject->GetFileByFilename(filename, false);
        if (not pProjectFile) return;

        wxArrayString buildTargets = pProjectFile->GetBuildTargets();
        if (not buildTargets.Count()) return;

        pTarget = pProject->GetBuildTarget(buildTargets[0]);
    }
    if (not pTarget) return;

    Compiler* pCompiler = CompilerFactory::GetCompiler(pTarget->GetCompilerID());
    wxString masterPath = pCompiler ? pCompiler->GetMasterPath() : "";
    wxString compilerID = pCompiler ? pCompiler->GetID() : "";
    CompilerPrograms compilerPrograms;

    // if no entry for compilerID get compiler include filenames
    if (pCompiler and (LSPCompilerIncludes.find(compilerID) == LSPCompilerIncludes.end()) )
    {
        compilerPrograms = pCompiler->GetPrograms() ;
        wxString exeCmd = masterPath + "\\bin\\" + compilerPrograms.CPP;
        exeCmd += " -E -Wp,-v -xc++ nul" ;
        if (not platform::windows)
           exeCmd.Replace("nul", "/dev/null") ;
        wxArrayString gccResults ;
        // The output we want will go to stderr
       wxExecute(exeCmd, gccResults, gccErrors, wxEXEC_SYNC);

        // Example response from "c++.exe -E -Wp,-v -xc++ nul":
        // F:\usr\proj\cbDevel31\trunk\src\output31_64>f:\usr\MinGW810_64seh\bin\g++.exe -E -Wp,-v -xc++ nul
        // Example result:
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++"
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32"
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward"
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/include"
        // ignoring nonexistent directory "C:/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64C:/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../include"
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed"
        // ignoring duplicate directory "f:/usr/MinGW810_64seh/lib/gcc/../../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include"
        // ignoring nonexistent directory "C:/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64/mingw/include"
        // #include "..." search starts here:
        // #include <...> search starts here:
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed
        //  f:/usr/MinGW810_64seh/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include
        // End of search list.
        // # 1 "nul"
        // # 1 "<built-in>"
        // # 1 "<command-line>"
        // # 1 "nul"

        LogManager* pLogMgr = Manager::Get()->GetLogManager();
        wxUnusedVar(pLogMgr);

        // Search for "#include.." lines in compiler response and pull out the
        // lines until "End of search list" string is reached.

        //output compiler includes of executing "compiler.exe -E -Wp,-v -xc++ nul"
        wxArrayString LSPParseExtraIncludes;
        LSPParseExtraIncludes.Clear();
        bool searchStartsHere = false;
        for (wxString& line : gccErrors)
        {
            //-pLogMgr->DebugLog(line); debugging
            if (line.StartsWith("#include <"))
            {
                searchStartsHere = true;
                continue; //jump past "#include <"
            }
            if (line.StartsWith("End of search list.")) break;
            if (not searchStartsHere) continue;
            line.Trim(true).Trim(false);
            wxFileName fnIncludeDir(line, "");
            if (fnIncludeDir.DirExists())
                fnIncludeDir.Normalize(wxPATH_NORM_DOTS | wxPATH_NORM_ABSOLUTE );
            else continue;
            wxString incFile = fnIncludeDir.GetPath();
            incFile.Replace("\\", "/");
            // lib/gcc/x86_64-w64-mingw32/8.1.0/include causes g++ undeclared identifier '__builtin_ia32_bsrsi' errors.
            if (incFile.Contains("/lib/gcc/") and incFile.EndsWith("/include") )
                continue; // skip this line
            if (searchStartsHere)
                LSPParseExtraIncludes.Add(incFile);
        }

        wxString compilerIncludes;
        for (wxString entry : LSPParseExtraIncludes)
            compilerIncludes += ("-I" + entry + " ");

        if (compilerIncludes.Length())
            LSPCompilerIncludes[compilerID] = compilerIncludes;

    }//endif get compiler include filenames

    // Get files that should be represented in compile_commands.json
    size_t fileCount = 0;
    for (FilesList::const_iterator flist_it = pProject->GetFilesList().begin(); flist_it != pProject->GetFilesList().end(); ++flist_it)
    {
        ProjectFile* pf = *flist_it;
        if ( pf and (pf->file.GetFullPath() == filename) )
        {
            if ( (FileTypeOf(pf->relativeFilename) == ftHeader)
              or (FileTypeOf(pf->relativeFilename) == ftSource)
              or (FileTypeOf(pf->relativeFilename) == ftTemplateSource) )
            {
                if ( AddFileToCompileDBJson(pProject, pTarget,  pf->file.GetFullPath(), &jdb) )
                    {  ++fileCount; break; }
            }
        }
    }

    if (fileCount) switch(1)
    {
        default:
        jsonFile.open (cdbFullPath, std::ofstream::out | std::ofstream::trunc);
        if (not jsonFile.is_open())
        {
            cbMessageBox("compile_commands.json file failed to open for output.\n");
            break;
        }
        jsonFile << jdb; //write file json object
        jsonFile.close();
    }

}//end UpdateCompilationDatabase()
// ----------------------------------------------------------------------------
void ProcessLanguageClient::CreateDiagnosticsLog()
// ----------------------------------------------------------------------------
{
    if (not m_pDiagnosticsLog ) //(ph 2021/01/8)
    {

        wxArrayInt widths;
        wxArrayString titles;
        titles.Add(_("File"));
        titles.Add(_("Line"));
        titles.Add(_("Text"));
        widths.Add(128);
        widths.Add(48);
        widths.Add(640);

        const int uiSize = Manager::Get()->GetImageSize(Manager::UIComponent::InfoPaneNotebooks);
        const int uiScaleFactor = Manager::Get()->GetUIScaleFactor(Manager::UIComponent::InfoPaneNotebooks);
        const wxString imgFile = ConfigManager::GetDataFolder()
                              + wxString::Format(_T("/resources.zip#zip:/images/%dx%d/filefind.png"),
                                                 uiSize, uiSize);
        wxBitmap* logbmp = new wxBitmap(cbLoadBitmapScaled(imgFile, wxBITMAP_TYPE_PNG, uiScaleFactor));

        m_pDiagnosticsLog = new LSPDiagnosticsResultsLog(titles, widths);
        CodeBlocksLogEvent evt(cbEVT_ADD_LOG_WINDOW, m_pDiagnosticsLog, _("LSP diagnostics"), logbmp);
        Manager::Get()->ProcessEvent(evt);
        // Ask DragScroll plugin to apply its support for this log
        wxWindow* pWindow = m_pDiagnosticsLog->m_pControl;
        cbPlugin* pPlgn = Manager::Get()->GetPluginManager()->FindPluginByName(_T("cbDragScroll"));
        if (pWindow && pPlgn)
        {
                wxCommandEvent dsEvt(wxEVT_COMMAND_MENU_SELECTED, XRCID("idDragScrollAddWindow"));
                dsEvt.SetClientData(pWindow);
                //pPlgn->AddPendingEvent(dsEvt);
                Manager::Get()->GetAppFrame()->GetEventHandler()->AddPendingEvent(dsEvt);
        }
    }

}//end createLog
